# Nom du workflow qui appara√Ætra dans l'interface GitHub Actions
name: CI/CD Complet (Build, Test, Release & Deploy)

# D√©clenche ce workflow sur chaque push et pull request sur la branche 'main'
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  # Permet d'ex√©cuter ce workflow manuellement
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  packages: write

# D√©finition des jobs (t√¢ches) √† ex√©cuter
jobs:
  # -----------------------------------------------------------
  # JOB 1: Build et Tests Unitaires pour les services Java (Maven)
  # -----------------------------------------------------------
  java_build:
    name: Build Services Java (Maven)
    runs-on: ubuntu-latest
    env:
      JAVA_VERSION: '21'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Setup Java ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'
      - name: Run Maven Build and Unit Tests
        run: mvn clean install
      - name: Upload Java Artifacts (JARs)
        uses: actions/upload-artifact@v4
        with:
          name: java-artifacts
          # IMPORTANT : Upload de tous les JARs n√©cessaires
          path: |
            **/target/*.jar
            !**/target/*-sources.jar
            !**/target/*-javadoc.jar

  # -----------------------------------------------------------
  # JOB 2: Build du Frontend (Node.js)
  # -----------------------------------------------------------
  frontend_build:
    name: Build Frontend (Node.js)
    runs-on: ubuntu-latest
    needs: java_build
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      - name: Setup Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json
      - name: Install Dependencies
        run: npm install
        working-directory: ./frontend
      - name: Run Frontend Build (Vite)
        run: npm run build
        working-directory: ./frontend
      - name: Upload Frontend Artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: ./frontend/dist

  # -----------------------------------------------------------
  # JOB 3: Versioning (Release Please) et Pr√©paration des Assets
  # -----------------------------------------------------------
  # -----------------------------------------------------------
  # JOB X: Run E2E Tests (Testcontainers)
  # -----------------------------------------------------------

  release_and_versioning:
    name: Automated Versioning (Release Please)
    runs-on: ubuntu-latest
    needs: [java_build, frontend_build]

    if: github.event_name != 'push' || !contains(github.event.head_commit.message, 'chore(release):')

    permissions:
      contents: write
      pull-requests: write

    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Java Artifacts
        uses: actions/download-artifact@v4
        with:
          name: java-artifacts
          path: ./.zip-content

      - name: Verify JARs presence
        run: |
          if [ -z "$(find ./.zip-content -name "*.jar" -print -quit)" ]; then
            echo "::error::No JAR files found in ./.zip-content. Deployment aborted."
            ls -R ./.zip-content
            exit 1
          fi
          echo "JAR files confirmed present."

      - name: Install ZIP Utility
        run: sudo apt-get install zip -y

      - name: Run Release Please
        uses: googleapis/release-please-action@v4
        id: release
        with:
          release-type: simple
          token: ${{ secrets.GITHUB_TOKEN }}

      # 2. Archiver le dossier (s'ex√©cute SEULEMENT si une release a √©t√© cr√©√©e)
      - name: Zip Java Artifacts for Release
        id: zip_java
        if: ${{ steps.release.outputs.release_created }}
        run: |
          VERSION_TAG=${{ steps.release.outputs.tag_name }}
          ZIP_NAME="java-artifacts-$VERSION_TAG.zip"
          
          zip -r $ZIP_NAME ./.zip-content
          echo "ZIP_FILE=$ZIP_NAME" >> $GITHUB_OUTPUT

      # 3. Upload des JARs en tant qu'Assets de la Release
      - name: Upload Java Artifacts to Release
        if: ${{ steps.release.outputs.release_created }}
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.release.outputs.upload_url }}
          asset_path: ${{ steps.zip_java.outputs.ZIP_FILE }}
          asset_name: ${{ steps.zip_java.outputs.ZIP_FILE }}
          asset_content_type: application/zip

  # -----------------------------------------------------------
  # JOB 4: D√©ploiement Docker du Frontend (GHCR)
  # -----------------------------------------------------------
  frontend_deploy:
    name: Docker Deploy Frontend to GHCR
    runs-on: ubuntu-latest
    needs: [frontend_build, release_and_versioning]
    if: ${{ needs.release_and_versioning.outputs.release_created }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Frontend Dist
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: ./frontend/dist

      - name: Docker Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Image Metadata
        id: meta
        run: |
          VERSION=${{ needs.release_and_versioning.outputs.tag_name }}
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/gamestack-frontend"
          
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and Push Docker Image for Frontend
        uses: docker/build-push-action@v5
        with:
          # Le contexte est le r√©pertoire du Dockerfile du frontend
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true

          tags: |
            ${{ steps.meta.outputs.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
            ${{ steps.meta.outputs.IMAGE_NAME }}:latest

  # -----------------------------------------------------------
  # JOB 5: D√©ploiement Docker (Services Java)
  # -----------------------------------------------------------
  deploy_java_services:
    name: Docker Deploy Java Services to GHCR
    runs-on: ubuntu-latest
    needs: [release_and_versioning, frontend_deploy] # D√©pend maintenant du frontend aussi
    if: ${{ needs.release_and_versioning.outputs.release_created }}

    strategy:
      matrix:
        service: [api-gateway, auth-service, collection-service, games-service]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Final Release Artifacts (JARs)
        uses: actions/download-artifact@v4
        with:
          name: java-artifacts
          path: ./downloaded-jars

      - name: Extract Java Artifacts
        run: |
          SERVICE_NAME=$(echo ${{ matrix.service }} | tr '[:upper:]' '[:lower:]')
          JAR_FILE=$(find ./downloaded-jars -name "$SERVICE_NAME*.jar" | head -n 1)
          
          if [ -z "$JAR_FILE" ]; then
            echo "::error::JAR file for ${SERVICE_NAME} not found in downloaded artifact."
            exit 1
          fi
          
          cp "$JAR_FILE" ./${SERVICE_NAME}.jar
          
          rm -rf downloaded-jars

      - name: Docker Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Image Metadata and JAR Name
        id: meta
        run: |
          VERSION=${{ needs.release_and_versioning.outputs.tag_name }}
          SERVICE_NAME=$(echo ${{ matrix.service }} | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/gamestack-${SERVICE_NAME}"
          JAR_NAME="${SERVICE_NAME}.jar" 
          
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "JAR_NAME=$JAR_NAME" >> $GITHUB_OUTPUT

      - name: Build and Push Docker Image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          build-args: |
            JAR_FILE=${{ steps.meta.outputs.JAR_NAME }}

          tags: |
            ${{ steps.meta.outputs.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
            ${{ steps.meta.outputs.IMAGE_NAME }}:latest

  # -----------------------------------------------------------
  # JOB 6: D√©ploiement Final sur le Serveur via SSH
  # -----------------------------------------------------------
  server_update:
    name: Activer la Mise √† Jour sur le Serveur (SSH)
    runs-on: ubuntu-latest
    # Ce job d√©pend du succ√®s de tous les d√©ploiements Docker pr√©c√©dents
    needs: [deploy_java_services, frontend_deploy]
    # S'ex√©cute SEULEMENT si une nouvelle release a √©t√© cr√©√©e et si les d√©ploiements Docker ont r√©ussi
    if: ${{ needs.release_and_versioning.outputs.release_created }}

    env:
      SSH_USER: ec2-user # üëà √Ä remplacer par votre utilisateur de d√©ploiement
      SSH_HOST: 51.21.131.204 # üëà √Ä remplacer par l'IP ou le FQDN de votre serveur
      DOCKER_COMPOSE_PATH: /home/ec2-user/ # üëà Le chemin o√π se trouve votre fichier docker-compose.yml sur le serveur

    steps:
      # 1. Configuration de l'agent SSH avec la cl√© priv√©e (stock√©e en secret)
      - name: Configurer l'agent SSH avec la cl√© priv√©e
        uses: webfactory/ssh-agent@v0.9.0
        with:
          # Utilise le secret cr√©√© √† l'√âtape 3 du guide pr√©c√©dent
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      # 2. Ajout de l'h√¥te du serveur aux h√¥tes connus (pour √©viter les avertissements SSH)
      - name: Ajouter l'h√¥te du serveur aux h√¥tes connus
        run: |
          # Ajoute l'h√¥te aux known_hosts pour la premi√®re connexion s√©curis√©e
          ssh-keyscan ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts

      # 3. Ex√©cution des commandes de mise √† jour Docker √† distance
      - name: Ex√©cuter le D√©ploiement Docker √† distance
        run: |
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} '
            echo "Connexion SSH r√©ussie au serveur..."
          
            # 1. Naviguer vers le r√©pertoire du docker-compose
            cd ${{ env.DOCKER_COMPOSE_PATH }}
          
            # 2. R√©cup√©rer les nouvelles images (pull)
            echo "R√©cup√©ration des nouvelles images Docker depuis GHCR..."
            docker-compose pull
          
            # 3. Mettre √† jour les conteneurs (up -d)
            # Cette commande arr√™te et recr√©e les conteneurs dont l\'image a chang√©.
            echo "Mise √† jour des services (docker compose up -d)..."
            docker-compose up -d
          
            # 4. Nettoyage des anciennes images (Optionnel mais recommand√©)
            echo "Nettoyage des images Docker non utilis√©es..."
            docker image prune -f
          
            echo "D√©ploiement final termin√© avec succ√®s."
          '
