# Nom du workflow qui apparaîtra dans l'interface GitHub Actions
name: 2. Docker Deploy to GHCR

# Déclenche ce workflow uniquement lorsqu'une nouvelle Release est publiée sur GitHub
on:
  release:
    types: [published]

permissions:
  # Lecture obligatoire pour accéder aux Assets de la Release
  contents: read
  # Nécessaire pour pousser les images sur le GitHub Container Registry (GHCR)
  packages: write

jobs:
  # Déploie les services Java (API Gateway, Auth, Collection, Games)
  deploy_java_services:
    runs-on: ubuntu-latest

    # AJOUT CRITIQUE DE PERMISSIONS AU NIVEAU DU JOB
    # Bien que les permissions globales soient "Read and write",
    # définir explicitement celles du job peut être nécessaire pour l'événement 'release'
    permissions:
      contents: read
      packages: write
      # Ajout de l'accès aux actions/scripts pour la lecture de l'événement
      actions: read

    strategy:
      matrix:
        service: [api-gateway, auth-service, collection-service, games-service]

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # --- ÉTAPE CRUCIALE : TÉLÉCHARGEMENT D'UN ASSET DE RELEASE ---
      - name: Download Java Artifacts (ZIP)
        id: download_java
        uses: actions/github-script@v7
        with:
          script: |
            // Import du module 'core' et 'fs' nécessaire pour l'exécution
            const core = require('@actions/core');
            const fs = require('fs');

            const releaseId = context.payload.release.id;
            const releaseAssets = context.payload.release.assets;
            const assetName = `java-artifacts-${context.payload.release.tag_name}.zip`;
            
            const asset = releaseAssets.find(asset => asset.name === assetName);

            if (!asset) {
              core.setFailed(`Asset ${assetName} not found in release assets for tag ${context.payload.release.tag_name}.`);
              return;
            }

            // Téléchargement de l'asset via l'API GitHub
            const downloadUrl = asset.url;
            const response = await github.request({
              method: 'GET',
              url: downloadUrl,
              headers: {
                Accept: 'application/octet-stream'
              }
            });

            // Écriture du fichier binaire téléchargé
            fs.writeFileSync(assetName, Buffer.from(response.data));
            
            core.setOutput('asset_file', assetName);
            console.log(`Successfully downloaded asset: ${assetName}`);


      - name: Extract Java Artifacts
        run: |
          # Installation de unzip (au cas où)
          sudo apt-get install unzip -y
          
          # Le fichier ZIP est téléchargé dans le répertoire courant
          unzip ${{ steps.download_java.outputs.asset_file }}
          
          # Les fichiers sont extraits dans le dossier 'java-artifacts-to-upload'. 
          # On déplace les JARs à la racine pour Docker
          mv java-artifacts-to-upload/* .
          
          # Nettoyage
          rm -rf java-artifacts-to-upload/

      # --- Configuration Docker/GHCR ---
      - name: Docker Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set Image Metadata and JAR Name
        id: meta
        run: |
          VERSION=${{ github.event.release.tag_name }}
          SERVICE_NAME=$(echo ${{ matrix.service }} | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME="ghcr.io/${{ github.repository_owner }}/gamestack-${SERVICE_NAME}"
          # Le nom du JAR doit correspondre à celui que Maven a généré (ex: api-gateway.jar)
          JAR_NAME="${SERVICE_NAME}.jar" 
          
          echo "IMAGE_NAME=$IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "JAR_NAME=$JAR_NAME" >> $GITHUB_OUTPUT

      - name: Build and Push Docker Image for ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          # Le contexte est la racine '.' où le JAR est maintenant extrait
          context: .
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          build-args: |
            JAR_FILE=${{ steps.meta.outputs.JAR_NAME }}

          tags: |
            ${{ steps.meta.outputs.IMAGE_NAME }}:${{ steps.meta.outputs.VERSION }}
            ${{ steps.meta.outputs.IMAGE_NAME }}:latest

# NOTE: Il faudrait un job similaire pour le frontend (s'il est déployé via Docker)
# ou un autre job pour un déploiement S3/Cloudflare.
